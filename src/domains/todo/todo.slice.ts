import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { addTodoAsync } from './todo.thunks';
import todoState, { Todo } from './todo.state';

export const todoSlice = createSlice({
	name: 'todo',
	initialState: todoState,
	reducers: {
		addTodo: (state, action: PayloadAction<{ todo: Todo }>) => {
			state.todos.push(action.payload.todo);
		},
		removeTodo: (state, action: PayloadAction<{ id: number }>) => {
			state.todos = state.todos.filter((t) => t.id !== action.payload.id);
		},
		toggleTodo: (state, action: PayloadAction<{ id: number }>) => {
			state.todos = state.todos.map((t) => {
				if (t.id === action.payload.id) t.completed = !t.completed;
				return t;
			});
		},
	},
	extraReducers: (builder) => {
		builder
			.addCase(addTodoAsync.pending, (state) => {
				state.status = 'loading';
			})
			.addCase(addTodoAsync.fulfilled, (state, action) => {
				state.todos.push(action.payload);
			})
			.addCase(addTodoAsync.rejected, (state) => {
				state.status = 'error';
			});
	},
});

/**
 * we can write "mutating" logic in reducers thanks to immer
 * it checks change made in the provisionary draft state compares
 * it to the single source of truth state and creates a new immutable state
 * based on the changes
 */

/**
 *  The `extraReducers` field lets the slice handle actions defined elsewhere,
 *  including actions generated by createAsyncThunk or in other slices.
 */

export const { addTodo, removeTodo, toggleTodo } = todoSlice.actions;
const todoReducer = todoSlice.reducer;
export default todoReducer;
